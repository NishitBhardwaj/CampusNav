Perfect. Now we **slow everything down**, remove confusion, and convert this into a **step-by-step execution roadmap** where you work on **ONE STEP AT A TIME**, like a real software project.

Iâ€™ll also **clearly explain the backend question** (Java / Node / Firebase / local) so you understand **why and when a backend is needed**.

---

# ðŸ§­ CAMPUSNAV â€“ STEP-BY-STEP EXECUTION PLAN

*(Hackathon-safe, real-world, fool-proof)*

This plan is divided into **7 clear phases**.
You **do NOT jump ahead**. You finish one phase â†’ then move to the next.

---

## ðŸ”´ PHASE 0: DECISIONS (DO THIS FIRST â€“ NO CODING)

### Goal

Lock decisions so you donâ€™t change direction mid-hackathon.

### Decisions to Lock

* âœ… Platform: **Mobile App**
* âœ… Framework: **Flutter**
* âœ… Scope: **ONE building, ONEâ€“TWO floors**
* âœ… Navigation type: **Offline, hybrid (sensors + QR + visuals)**
* âœ… Demo priority > full accuracy

ðŸ“Œ **Important**
At this stage, **NO backend server is required**.
We start **local-first**.

âœ” Output of Phase 0:

* Written problem statement (5â€“6 lines)
* Final feature list (already locked)
* Agreement: *â€œNo new features will be addedâ€*

---

## ðŸŸ  PHASE 1: USER FLOW & SCREENS (UX FIRST)

### Goal

Understand **how a user moves through the app**, before tech.

### Screens to Design (on paper / Figma / notebook)

1. Splash / Start
2. â€œScan QR to startâ€ OR â€œSelect nearby landmarkâ€
3. Search screen (AI assistant)
4. Map + navigation screen
5. â€œIâ€™m lostâ€ fallback screen
6. Manual / photo guidance screen
7. Demo mode toggle (hidden)

ðŸ“Œ **No backend. No sensors yet. Only flow.**

âœ” Output of Phase 1:

* Clear screen sequence
* What happens if user clicks X / fails / gets confused

---

## ðŸŸ¡ PHASE 2: DATA & MAP MODEL (THE FOUNDATION)

### Goal

Create the **campus as data**, not visuals.

### What You Build

* `graph.json`
* Local personnel database

### Data You Define

#### A. Nodes

* Entrance
* Corridors
* Stairs
* Offices (Dean, Registrar, etc.)

#### B. Edges

* Walkable paths between nodes
* Distance in meters or steps

#### C. Personnel Data

* Name
* Role
* Office Node ID
* Last updated date

ðŸ“Œ Stored locally using **Hive / Isar**

âœ” Output of Phase 2:

* Working campus graph (JSON)
* Local DB structure
* Zero UI, zero backend

---

## ðŸŸ¢ PHASE 3: CORE NAVIGATION ENGINE (NO UI YET)

### Goal

Make the **brain** work before visuals.

### What You Implement

1. **A* Pathfinding**

   * Input: Start Node â†’ End Node
   * Output: List of nodes (path)

2. **Rail Snapping Logic**

   * User position always stays on valid path
   * Prevents drifting through walls

3. **Dynamic Rerouting**

   * Mark edge as blocked
   * Recalculate path instantly

ðŸ“Œ Still **offline, local only**.

âœ” Output of Phase 3:

* Given any two nodes â†’ path is correct
* Blocked path â†’ reroutes correctly

---

## ðŸ”µ PHASE 4: POSITION TRACKING (HYBRID LOGIC)

### Goal

Move the user dot **safely**, not perfectly.

### Step-by-Step

1. **Activity Recognition**

   * Detect walking vs still
   * Freeze dot when still

2. **Step Counting**

   * Each step = small forward movement

3. **Heading Control**

   * Ignore compass if phone tilted
   * Assume direction from path

4. **QR Reset**

   * Scan QR â†’ snap to exact node

ðŸ“Œ Still **NO backend**.

âœ” Output of Phase 4:

* Dot moves only when user walks
* QR scan fixes drift
* No random movement

---

## ðŸŸ£ PHASE 5: UI IMPLEMENTATION (NOW VISUALS)

### Goal

Make it **clear, simple, and demo-safe**.

### UI Components

* SVG floor map
* Path overlay
* Live dot
* Confidence indicator
* Search bar
* â€œIâ€™m lostâ€ button

### Navigation UI Modes

* Normal map mode
* Photo carousel mode (fallback)
* Manual step mode

ðŸ“Œ This is where your **reference UI image inspiration fits**.

âœ” Output of Phase 5:

* Judges can understand navigation in 5 seconds
* Even if sensors fail, UI still guides

---

## ðŸŸ¤ PHASE 6: AI ASSISTANT (OFFLINE-FIRST)

### Goal

Enable **search â†’ navigation**, not ChatGPT.

### How It Works

* User types: â€œDean of Engineeringâ€
* Fuzzy search in local DB
* Finds matching person
* Returns office node
* Triggers navigation

### Add Transparency

* â€œData last updated on ___â€

ðŸ“Œ Still **NO server backend required**.

âœ” Output of Phase 6:

* AI feels smart
* Zero hallucination
* Works without internet

---

## âš« PHASE 7: BACKEND (IMPORTANT â€“ READ CAREFULLY)

### â— DO YOU REALLY NEED A BACKEND?

**For the hackathon demo â†’ NO (not mandatory)**
**For real-world scalability â†’ YES**

So we design backend **as a future layer**, not a dependency.

---

## âœ… BACKEND STRATEGY (PROPER & REALISTIC)

### Option 1: Local-First (Hackathon Mode)

* Everything runs on device
* Fast
* Reliable
* No internet risk

ðŸ‘‰ **THIS is what you demo**

---

### Option 2: Sync Backend (Post-Hackathon / Bonus)

You add backend **only for syncing**, not live navigation.

### Recommended Backend Stack

#### Backend Language

* **Java (Spring Boot)** âœ… OR
* Node.js (Express)

### Backend Responsibilities

* Store:

  * Campus maps
  * Personnel updates
* Sync data when internet is available
* Admin dashboard (future)

### Architecture

```
Mobile App (Offline)
   â†“ (when internet)
Backend API
   â†“
Database
```

ðŸ“Œ Navigation **never depends on backend**.

---

## ðŸ”§ BACKEND PHASE BREAKDOWN (IF TIME ALLOWS)

### Phase B1: Backend Setup

* Java Spring Boot REST API
* Endpoints:

  * `/campus-data`
  * `/personnel`

### Phase B2: Sync Logic

* App checks internet
* Pulls updated JSON
* Saves locally

### Phase B3: Admin Use Case (Optional)

* Update staff room numbers
* Push updates

---

## ðŸ§¨ PHASE 8: DEMO SAFETY & POLISH (NON-NEGOTIABLE)

### Must-Haves

* Demo mode toggle
* Simulated walking
* Fake perfect navigation
* No crashes

### Why?

Hackathons are **live theatre**.
You must control the narrative.

---

# ðŸ§  FINAL SIMPLE RULE (REMEMBER THIS)

> **Navigation logic first â†’ UI second â†’ AI third â†’ backend last**

If you reverse this, you will fail.

---

## âœ… WHAT YOU SHOULD DO NEXT (ONE STEP ONLY)

ðŸ‘‰ **Start with PHASE 1 (User Flow & Screens)**
Do NOT code yet.

If you want, next I can:

* Convert Phase 1 into **exact screen list**
* Create **backend API design (Java)**
* Create **task checklist for each phase**
* Or **draw architecture diagram**

Just tell me **which phase you want to start with**.
